# This script demonstrates three key Python concepts:
# 1. Filtering numbers using for loops and conditions
# 2. List comprehensions
# 3. Enumerating elements with their indexes

# ---------------------------------------------
# Print numbers from 1 to 20 that are NOT divisible by 3
print("Numbers from 1 to 20 that are not divisible by 3:")
for x in range(1, 21):
    if x % 3 != 0:
        print(x)

# Same output using a list comprehension
print("\nSame result using list comprehension:")
print([y for y in range(1, 21) if y % 3 != 0])

# ---------------------------------------------
# Demonstrating enumerate() with a list of fruits
fruits = ["apple", "banana", "cherry"]
print("\nEnumerating fruits with their indexes:")
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")

# ---------------------------------------------
# This block collects 5 numbers from the user,
# stores them in a list, and calculates their sum and average.

i = 1
total = 0
all_nums = []

while i <= 5:
    num = int(input(f"Insert number #{i} of 5: "))
    all_nums.append(num)
    total += num
    i += 1

# Display all entered numbers
print(f"All numbers: {all_nums}")
print(f"The sum is {total}")
print(f"The average is {total / 5}")

# ---------------------------------------------
# Filter positive and negative numbers from a mixed list

# Original list with positive, negative, and zero values
numbers = [4, -1, 7, 0, -3, 10, -5]

# Create empty lists for classified numbers
positive = []
negative = []

for num in numbers:
    if num > 0:
        positive.append(num)
    elif num < 0:
        negative.append(num)

# Display classification results
print(f"Positive numbers: {positive}")
print(f"Negative numbers: {negative}")
print("Zero values are ignored.")  # No variable interpolation here, so no f-string needed


# ---------------------------------------------
# Note:
# I realize this code could be further optimized, 
# but I intentionally chose to move forward instead of getting stuck perfecting every detail.
# As I learned in my previous job: prioritizing and optimizing is usually more valuable than perfection. 
# (Spoiler: not always, but almost.)
# Let's see if this mindset works in Data Science too.
